import { prisma } from '../lib/prisma';
import { VehicleStatus } from '@prisma/client';
import { redis } from '../lib/redis';

export class AnalyticsService {
    /**
     * Calculates total operational cost generated by a specific vehicle.
     */
    public static async getVehicleTotalOperationalCost(vehicleId: string): Promise<number> {
        const expensesAgg = await prisma.expense.aggregate({ where: { vehicleId }, _sum: { amount: true } });
        const maintenanceAgg = await prisma.maintenanceLog.aggregate({ where: { vehicleId }, _sum: { cost: true } });
        const fuelAgg = await prisma.fuelLog.aggregate({ where: { vehicleId }, _sum: { cost: true } });

        return (expensesAgg._sum.amount || 0) + (maintenanceAgg._sum.cost || 0) + (fuelAgg._sum.cost || 0);
    }

    /**
     * Calculates Cost Per KM using recorded distances generated inside dispatch loops.
     */
    public static async getVehicleCostPerKm(vehicleId: string): Promise<number> {
        const totalCost = await this.getVehicleTotalOperationalCost(vehicleId);
        const tripAgg = await prisma.trip.aggregate({ where: { vehicleId, distanceKm: { not: null } }, _sum: { distanceKm: true } });
        const totalKm = tripAgg._sum.distanceKm || 0;

        return totalKm === 0 ? 0 : Number((totalCost / totalKm).toFixed(2));
    }

    /**
     * Calculates Global Fleet KPIs
     */
    public static async getFleetKPIs() {
        // Optimized using Redis atomic counters + fallback to Postgres
        const activeStr = await redis.get('kpi:active_vehicles');
        let totalActive = activeStr ? parseInt(activeStr, 10) : 0;

        const inShopStr = await redis.get('kpi:vehicles_in_shop');
        let inShop = inShopStr ? parseInt(inShopStr, 10) : 0;

        const onTripStr = await redis.get('kpi:vehicles_on_trip');
        let onTrip = onTripStr ? parseInt(onTripStr, 10) : 0;

        // Fallback to query if redis keys are missing
        if (!activeStr || !inShopStr || !onTripStr) {
            const statusCounts = await prisma.vehicle.groupBy({
                by: ['status'],
                _count: { id: true },
                where: { status: { not: VehicleStatus.RETIRED } }
            });
            totalActive = 0; onTrip = 0; inShop = 0;
            for (const group of statusCounts) {
                totalActive += group._count.id;
                if (group.status === VehicleStatus.ON_TRIP) onTrip = group._count.id;
                if (group.status === VehicleStatus.IN_SHOP) inShop = group._count.id;
            }
            // Seed Redis since they were missing
            await redis.set('kpi:active_vehicles', totalActive);
            await redis.set('kpi:vehicles_in_shop', inShop);
            await redis.set('kpi:vehicles_on_trip', onTrip);
        }

        const utilizationPercent = totalActive === 0 ? 0 : Number(((onTrip / totalActive) * 100).toFixed(2));
        const downtimePercent = totalActive === 0 ? 0 : Number(((inShop / totalActive) * 100).toFixed(2));

        // 2. Global Fuel Efficiency (km/L)
        const trips = await prisma.trip.aggregate({ where: { distanceKm: { not: null } }, _sum: { distanceKm: true } });
        const fuels = await prisma.fuelLog.aggregate({ _sum: { gallons: true } });

        const totalDistance = trips._sum.distanceKm || 0;
        const totalLiters = (fuels._sum.gallons || 0) * 3.78541; // Convert gallons to liters
        const fuelEfficiencyKmL = totalLiters === 0 ? 0 : Number((totalDistance / totalLiters).toFixed(2));

        return { totalActiveVehicles: totalActive, utilizationPercent, downtimePercent, fuelEfficiencyKmL };
    }

    /**
     * Calculates the ROI of a specific vehicle
     */
    public static async getVehicleROI(vehicleId: string, revenuePerKm: number = 2.50) {
        const totalCost = await this.getVehicleTotalOperationalCost(vehicleId);
        const tripAgg = await prisma.trip.aggregate({ where: { vehicleId, distanceKm: { not: null } }, _sum: { distanceKm: true } });

        const totalDistance = tripAgg._sum.distanceKm || 0;
        const revenue = totalDistance * revenuePerKm;

        const roiPercent = totalCost === 0 ? (revenue > 0 ? 100 : 0) : Number((((revenue - totalCost) / totalCost) * 100).toFixed(2));

        return { totalCost, totalDistance, totalRevenue: revenue, netProfit: revenue - totalCost, roiPercent };
    }

    /**
     * Generates a global fleet CSV avoiding N+1 problems via efficient grouping and in-memory Map intersections.
     */
    public static async generateFleetReportCSV(): Promise<string> {
        const vehicles = await prisma.vehicle.findMany({
            where: { status: { not: VehicleStatus.RETIRED } },
            select: { id: true, licensePlate: true, make: true, model: true, status: true }
        });

        // Solve N+1: O(1) aggregations
        const expensesAgg = await prisma.expense.groupBy({ by: ['vehicleId'], _sum: { amount: true } });
        const maintAgg = await prisma.maintenanceLog.groupBy({ by: ['vehicleId'], _sum: { cost: true } });
        const fuelAgg = await prisma.fuelLog.groupBy({ by: ['vehicleId'], _sum: { cost: true } });
        const distanceAgg = await prisma.trip.groupBy({ by: ['vehicleId'], _sum: { distanceKm: true } });

        const costsMap = new Map<string, number>();
        const distanceMap = new Map<string, number>();
        const addToCost = (id: string, cost: number) => costsMap.set(id, (costsMap.get(id) || 0) + cost);

        expensesAgg.forEach((e: any) => addToCost(e.vehicleId, e._sum.amount || 0));
        maintAgg.forEach((m: any) => addToCost(m.vehicleId, m._sum.cost || 0));
        fuelAgg.forEach((f: any) => addToCost(f.vehicleId, f._sum.cost || 0));
        distanceAgg.forEach((d: any) => distanceMap.set(d.vehicleId, d._sum.distanceKm || 0));

        // Construct CSV String
        const revenuePerKm = 2.50;
        let csv = "Vehicle ID,License Plate,Make,Model,Status,Total Cost,Total KM,Cost Per KM,Net Profit,ROI %\n";

        vehicles.forEach((v: any) => {
            const totalCost = costsMap.get(v.id) || 0;
            const totalDistance = distanceMap.get(v.id) || 0;
            const costPerKm = totalDistance === 0 ? 0 : totalCost / totalDistance;
            const revenue = totalDistance * revenuePerKm;
            const netProfit = revenue - totalCost;
            const roiPercent = totalCost === 0 ? (revenue > 0 ? 100 : 0) : ((netProfit) / totalCost) * 100;

            csv += `${v.id},${v.licensePlate},${v.make},${v.model},${v.status},${totalCost.toFixed(2)},${totalDistance.toFixed(2)},${costPerKm.toFixed(2)},${netProfit.toFixed(2)},${roiPercent.toFixed(2)}\n`;
        });

        return csv;
    }

    /**
     * Gets time series data for fuel efficiency per month
     */
    public static async getFuelEfficiencyTimeSeries() {
        const trips = await prisma.$queryRaw<any[]>`
            SELECT DATE_TRUNC('month', "createdAt") as month, SUM("distanceKm") as total_distance
            FROM "Trip"
            WHERE "distanceKm" IS NOT NULL
            GROUP BY DATE_TRUNC('month', "createdAt")
            ORDER BY month ASC
        `;

        const fuels = await prisma.$queryRaw<any[]>`
            SELECT DATE_TRUNC('month', "dateFilled") as month, SUM("gallons") as total_gallons
            FROM "FuelLog"
            GROUP BY DATE_TRUNC('month', "dateFilled")
            ORDER BY month ASC
        `;

        const dataPoints: { month: string; efficiencyKmL: number; }[] = [];

        // Map combinations
        const distanceMap = new Map(trips.map(t => [t.month.toISOString(), t.total_distance]));

        for (const fuel of fuels) {
            const monthStr = fuel.month.toISOString();
            const totalGallons = fuel.total_gallons || 0;
            const totalDistance = distanceMap.get(monthStr) || 0;

            const totalLiters = totalGallons * 3.78541;
            const efficiency = totalLiters === 0 ? 0 : (totalDistance / totalLiters);
            dataPoints.push({
                month: monthStr,
                efficiencyKmL: Number(efficiency.toFixed(2))
            });
        }

        return dataPoints;
    }
}
