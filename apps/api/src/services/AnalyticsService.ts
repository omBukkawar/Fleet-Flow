import { prisma } from '../lib/prisma';
import { VehicleStatus } from '@prisma/client';

export class AnalyticsService {
    /**
     * Calculates total operational cost generated by a specific vehicle.
     */
    public static async getVehicleTotalOperationalCost(vehicleId: string): Promise<number> {
        const expensesAgg = await prisma.expense.aggregate({ where: { vehicleId }, _sum: { amount: true } });
        const maintenanceAgg = await prisma.maintenanceLog.aggregate({ where: { vehicleId }, _sum: { cost: true } });
        const fuelAgg = await prisma.fuelLog.aggregate({ where: { vehicleId }, _sum: { cost: true } });

        return (expensesAgg._sum.amount || 0) + (maintenanceAgg._sum.cost || 0) + (fuelAgg._sum.cost || 0);
    }

    /**
     * Calculates Cost Per KM using recorded distances generated inside dispatch loops.
     */
    public static async getVehicleCostPerKm(vehicleId: string): Promise<number> {
        const totalCost = await this.getVehicleTotalOperationalCost(vehicleId);
        const tripAgg = await prisma.trip.aggregate({ where: { vehicleId, distanceKm: { not: null } }, _sum: { distanceKm: true } });
        const totalKm = tripAgg._sum.distanceKm || 0;

        return totalKm === 0 ? 0 : Number((totalCost / totalKm).toFixed(2));
    }

    /**
     * Calculates Global Fleet KPIs
     */
    public static async getFleetKPIs() {
        // 1. Fleet Utilization and Downtime
        const statusCounts = await prisma.vehicle.groupBy({
            by: ['status'],
            _count: { id: true },
            where: { status: { not: VehicleStatus.RETIRED } }
        });

        let totalActive = 0, onTrip = 0, inShop = 0;
        for (const group of statusCounts) {
            totalActive += group._count.id;
            if (group.status === VehicleStatus.ON_TRIP) onTrip = group._count.id;
            if (group.status === VehicleStatus.IN_SHOP) inShop = group._count.id;
        }

        const utilizationPercent = totalActive === 0 ? 0 : Number(((onTrip / totalActive) * 100).toFixed(2));
        const downtimePercent = totalActive === 0 ? 0 : Number(((inShop / totalActive) * 100).toFixed(2));

        // 2. Global Fuel Efficiency (km/L)
        const trips = await prisma.trip.aggregate({ where: { distanceKm: { not: null } }, _sum: { distanceKm: true } });
        const fuels = await prisma.fuelLog.aggregate({ _sum: { gallons: true } });

        const totalDistance = trips._sum.distanceKm || 0;
        const totalLiters = (fuels._sum.gallons || 0) * 3.78541; // Convert gallons to liters
        const fuelEfficiencyKmL = totalLiters === 0 ? 0 : Number((totalDistance / totalLiters).toFixed(2));

        return { totalActiveVehicles: totalActive, utilizationPercent, downtimePercent, fuelEfficiencyKmL };
    }

    /**
     * Calculates the ROI of a specific vehicle
     */
    public static async getVehicleROI(vehicleId: string, revenuePerKm: number = 2.50) {
        const totalCost = await this.getVehicleTotalOperationalCost(vehicleId);
        const tripAgg = await prisma.trip.aggregate({ where: { vehicleId, distanceKm: { not: null } }, _sum: { distanceKm: true } });

        const totalDistance = tripAgg._sum.distanceKm || 0;
        const revenue = totalDistance * revenuePerKm;

        const roiPercent = totalCost === 0 ? (revenue > 0 ? 100 : 0) : Number((((revenue - totalCost) / totalCost) * 100).toFixed(2));

        return { totalCost, totalDistance, totalRevenue: revenue, netProfit: revenue - totalCost, roiPercent };
    }

    /**
     * Generates a global fleet CSV avoiding N+1 problems via efficient grouping and in-memory Map intersections.
     */
    public static async generateFleetReportCSV(): Promise<string> {
        const vehicles = await prisma.vehicle.findMany({
            where: { status: { not: VehicleStatus.RETIRED } },
            select: { id: true, licensePlate: true, make: true, model: true, status: true }
        });

        // Solve N+1: O(1) aggregations
        const expensesAgg = await prisma.expense.groupBy({ by: ['vehicleId'], _sum: { amount: true } });
        const maintAgg = await prisma.maintenanceLog.groupBy({ by: ['vehicleId'], _sum: { cost: true } });
        const fuelAgg = await prisma.fuelLog.groupBy({ by: ['vehicleId'], _sum: { cost: true } });
        const distanceAgg = await prisma.trip.groupBy({ by: ['vehicleId'], _sum: { distanceKm: true } });

        const costsMap = new Map<string, number>();
        const distanceMap = new Map<string, number>();
        const addToCost = (id: string, cost: number) => costsMap.set(id, (costsMap.get(id) || 0) + cost);

        expensesAgg.forEach((e: any) => addToCost(e.vehicleId, e._sum.amount || 0));
        maintAgg.forEach((m: any) => addToCost(m.vehicleId, m._sum.cost || 0));
        fuelAgg.forEach((f: any) => addToCost(f.vehicleId, f._sum.cost || 0));
        distanceAgg.forEach((d: any) => distanceMap.set(d.vehicleId, d._sum.distanceKm || 0));

        // Construct CSV String
        const revenuePerKm = 2.50;
        let csv = "Vehicle ID,License Plate,Make,Model,Status,Total Cost,Total KM,Cost Per KM,Net Profit,ROI %\n";

        vehicles.forEach((v: any) => {
            const totalCost = costsMap.get(v.id) || 0;
            const totalDistance = distanceMap.get(v.id) || 0;
            const costPerKm = totalDistance === 0 ? 0 : totalCost / totalDistance;
            const revenue = totalDistance * revenuePerKm;
            const netProfit = revenue - totalCost;
            const roiPercent = totalCost === 0 ? (revenue > 0 ? 100 : 0) : ((netProfit) / totalCost) * 100;

            csv += `${v.id},${v.licensePlate},${v.make},${v.model},${v.status},${totalCost.toFixed(2)},${totalDistance.toFixed(2)},${costPerKm.toFixed(2)},${netProfit.toFixed(2)},${roiPercent.toFixed(2)}\n`;
        });

        return csv;
    }
}
